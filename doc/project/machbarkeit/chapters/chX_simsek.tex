\chapter {Technische Machbarkeit}
Diese technische Machbarkeit bezieht sich auf das Teilprojekt der Schaltvorhersage, welche berechnen soll mit welchem Gang der Fahrer gerade am meisten Kraftstoff sparen würde oder mit welchem der Fahrer das Drehmoment seines Fahrzeuges möglichst hoch halten könnte.	
\section {Varianten}
In diesem Teil meiner technischen Machbarkeit muss behandelt werden welche Algorithmen für die Berechnung des spritsparensten Gang oder für den leistungsstärksten Gang verwendet werden müssen.
[BibTeX Literatur: 3]
\subsection {Parameter}
Diese Subsection bearbeitet die technische Machbarkeit der Schaltvorschlagberechnung anhand der Parameter (PIDs), welche für den Algorithmus ALPHAshift verwendet werden, die in der OBD-II Schnittstelle vorhanden sind.
%Weitere Ausführungen zu den Algorithmen folgen.

\textbf{Kosten-Parameter}
Der Kostenparameter wird vor allem aus den Informationen über den Kraftstoffverbrauch bezogen. 
Diese sind unter anderem folgende:

\textit{cost_map}:
\begin{itemize}
	\item Fuel Level Input (Mode 01; PID 2F [1-100%]) -> Menge des Kraftstoffs die noch vorhanden ist
	\item Fuel Type (Mode 01; PID 51 [(0)/1-23]) -> Kosten des verwendeten Kraftstoffs
	\item Engine Fuel Rate (Mode 01; PID 5E [L/h]) -> Zeit in Verbindung mit Kraftstoffverbrauch 
	\item Distance traveled since codes cleared (Mode 01; PID 31 [0-65535 km]) -> Distanz die mit der Menge des Kraftstoffs gefahren wurde
	\item Distanz direkt aus dem CarPC [km]
\end{itemize}

\textit{Analyse}
Aufgrund der oben gezeigten verfügbaren Parameter lässt sich schließen dass die Parameter der OBD-Schnittstelle für den Algorithmus perfekt sind, da alle Anforderungen davon erfüllt werden.

\textbf{Geschwindigkeit-Parameter}
Die Geschwindigkeit Parameter entscheiden zwischen welchen Bereichen die Gangschaltung operieren sollte um optimale Effizienz und möglichst geringe Abnutzung zu erzielen. Selbige Parameter müssen auch für die Berechnungen des 
Drehmoment-staken Ganges verwendet, allerdings wird bei dieser Berechnung nicht auf die Abnutzung des Getriebes geachtet.

All diese Parameter des Algorithmus benötigen die unten angeführten Parameter aus dem Motormanagement:
\begin{itemize}
	\item \textit{min_speed_radps}
	\cite{The speed below which the transmission must downshift}
	\item \textit{max_speed_padps}
	\cite{The speed above which the transmission must upshift.}
	\item \textit{upshift_min_speed_radps}
	\cite{The minimum speed required in a gear before upshift to that gear is allowed. Provides headroom above the min_speed_radps}
	\item \textit{downshift_max_speed_radps}
	\cite{The maximum speed allowed in a gear at the time of downshifting to that gear. [...] Provides headroom to downshift without hitting the max_speed_radps}
	\item
\end{itemize}
Für alle oben angeführten Algorithmus-Parameter werden folgende OBD-Parameter benötigt:
\begin{itemize}
	\item Number of gears (vom User selbst eingegeben [4-7])
	\item Gear ratio (nur möglich wenn der User die genaue Type seines Getriebes angeben kann)
	\item Vehicle Speed (Mode 01; PID 0D [0-255 km/h])
\end{itemize}

\textit{Analyse}
Aufgrund der oben gezeigten verfügbaren Parameter lässt sich schließen dass diese Parameter für den Algorithmus zureichend sind, allerdings muss der Anzahl der Gänge und die Übersetzung direkt vom User erfragt werden was ein großes Fehlerpotenzial bietet.

\textbf{Performance-Parameter}
Die Performance Parameter versuchen ein Gleichgewicht zwischen Preis und Leistungsreserven. Der eigentliche Kickdown der Quelle wird in diesem Fall für den maximalen Drehmoment Modus weiterverwendet.

All diese Parameter des Algorithmus benötigen die unten angeführten Parameter aus dem Motormanagement:
\begin{itemize}
	\item \textit{required_cost_benefit_ratio}
	\cite{Represents the minimum benefit that must be available before a cost based shift will be allowed.}
	\item \textit{upshift_min_torque_reserve_ratio}
	\cite{Specifies the amount of headroom, in terms of full torque, [...] to prevent upshifting too close to full load in a higher gear.}
	\item \textit{max_speed_shift_increment}
	\cite{Determines the number of gears to shift by when upshifting at max_speed_radps. Typically one, though especially for larger amout of gears availible also often 2.}
	\item \textit{max_input_torque_curve_Nm}
	\cite{Used to specify the powertrain torque availible.}
\end{itemize}
Für alle oben angeführten Algorithmus-Parameter werden folgende OBD-Parameter benötigt:
\begin{itemize}
	\item Engine reference torque (Mode 01; PID 63 [0-65535 Nm])
	\item Leistungskurve anhand von Drehmoment (entweder durch Kalibrierung oder durch Auslesung aus der Datenbank)
	\item Engine percent torque data (Mode 01; PID 64 [-125 - 125 %])
	\item Vehicle Speed (Mode 01; PID 0D [0-255 km/h])
	\item Number of gears [4-7]
\end{itemize}

\textit{Analyse}
Aufgrund der oben gezeigten verfügbaren Parameter lässt sich schließen dass diese Parameter für den Algorithmus zureichend erfüllt werden können. Leider wird nur der Erhalt des maximalen Drehmoments und der Anzahl der Gänge schwierig, da beides entweder aus einer großen Datenbank ausgelesen werden müsste, welche aktuell gehalten werden muss oder direkt aus einer Usereingabe erlangt werden muss, was großes Fehlerpotenzial birgt. 

\textbf{Zeit-Parameter}
Die Zeitparameter sind großteils Schaltverzögerungen und Zeitunterschiede um fehlerhafte Eingaben des Benutzers eines Automatikgetriebes zu vermeiden. Dadurch sind diese Parameter für mich nicht von Relevanz.
\textbf{Setup-Parameter}
Diese Parameter sind mit Metadaten für ein Getriebe zu vergleichen, dabei sind folgende für mich relevant:
\begin{itemize}
	\item \textit{launch_gear_num}
	\cite{Specifies the normal gear to use when launching from zero speed.}
	\item \textit{restrict_skip_shifts}
	\cite{If set to 'true' forces shifts to be sequential, [...] typically true for transmissions with less than 7 gears.}
\end{itemize}

\textit{Analyse}
Da die Setup Parameter alle nur direkt vom User erfragt werden können, weil derartige Gang-spezifischen Daten nicht in der OBD Schnittstelle möglich sind, würde sich für mich die Frage stellen ob es nicht besser wäre die Applikation auf PKW's ausschließlich zu beschränken, wodurch man aber auch einen Großteil der Erweiterungsfähigkeit auf andere Fahrzeuge nehmen würde. Daher würde ich diese Parameter auf 1 und True setzen um die Werte nicht Userspezifisch abfragen zu müssen und um die Applikation auf PKW zu limitieren. 

\textbf{Parameter - Conclusio}
Aufgrund der oberen Analysen schließe ich dass mögliche Risikofaktoren allen voran die fehlerhafte Nutzereingabe von Daten wie der Ganganzahl, Getriebetype oder Motorleistung. Abgesehen von diesen Problemen dürfte es jedoch ausschließlich mittels Daten der OBD Schnittstelle möglich sein einen Schaltvorschlag zu berechnen.


\subsection {Programmiersprachen}
Bei den Programmiersprachen bestand die Auswahl zwischen Framework Python, native Java und Hybrid mit Java und HTML.
Dabei fiel für uns vor allem aufgrund von der Verbindung mit einer Webapplikation die Wahl auf eine hybride Applikation. 

Es fällt die Auswahl auf eines der folgenden Frameworks:
\begin{itemize}
	\item \hyperref[Codename One]{https://www.codenameone.com/pricing.html} Java
	\item \hyperref[Firebase]{https://www.firebase.com/pricing.html} Android/iOS/JavaScript SDK
	\item \hyperref[appmethod]{http://www.appmethod.com/de/pricing} C++
	\item \hyperref[ionic]{http://ionicframework.com/} HTML, CSS, JS; Built with Sass, optimized with AngularJS
\end{itemize}

\textit{Dokumentation}
Alle sind gut dokumentiert, Codename One und Firebase bieten sogar eine eingeschränkte kostenlose Option.
ionic ist von sogar OpenSource und hat eine tolle einsteigerfreundliche Dokumentation

\textit{Usage/Charakteristika}
\begin{itemize}
	\item Codename One bietet eine Java SDK um eine App welche auf iOS, Windows oder Android lauffähig ist
	\item Firebase bietet eine Android, iOS und JavaScript SDK um eine vielseitig kompatible mobile oder web Applikation zu entwickeln. 
	\item Mittels appmethod kann man mit einer C++ Codebasis eine Android, iOS, MacOSX und sogar eine Windows Applikation entwickeln.
	\item Bei ionic wird die App von einer mobil-freundlichen HTML, CSS und JS Library entwickelt, während sie dann mit Sass auf das jeweilige App Format konvertiert wird und mit Angular JS optimiert wird. 
\end{itemize}

\textit{Community}
\begin{itemize}
	\item Codename One bietet einen Blog, eine in die Webseite eingebundene Google Discussion und einen Stackoverflow codenameone-Tag.
	\item Firebase hat einen Blog und über 25000 Facebook likes, aber sonst leider nur ein GitHub um Issues zu publizieren und eigene Support Emails, also ist hier alles sehr zentralisiert gesteuert. 
	\item appmethod hat eine Github page, welche aber ebenfalls eher durch den Support mit Issues gefüllt wird und verlinkt für die Community auf die Homepage der Mutterfirma "Embarcadero", welche auch ein Forum anbieten
	\item ionic hat eine großes community-driven Forum, welches bei vielen Beiträgen mehrere hundert Antworten als Wissenserweiterung anbietet.
\end{itemize}

\textit{Performance}
\begin{itemize}
	\item Codename One verwendet SaaS für die Kompilierung der App und verwendet eine VM die Java zu C für iOS macht. Die Performance ist hoch da es die nativen gaming Plattformen des jeweiligen OS verwendet. 
	\item Firebase verwendet die Forge UI und ist dadurch auf große Datensätze sogar ausgelegt, nur muss man achten diese zu denormieren.
	\item Da appmethod C++ als Programmiersprache verwendet, welche direkt auf der CPU laufen kann, appmethod performant.
	\item In einem Post von Sep.2014 wird ionic als weniger performant gesehen. Document Object Model (DOM) sollten möglichst selten angezeigt werden um gute Performance und Seite zu Seite Wechsel sollten auch unterlassen werden. Allerdings scheint das ionic Team sehr Performance fokussiert zu sein.
\end{itemize}

\textit{Last Update}
\begin{itemize}
	\item Codename One: neuester Blogbeitrag: 14.10.2015
	\item Firebase: Github letzter Commit: vor 14 Stunden
	\item appmethod: Github letzter Commit: 21.09.2015
	\item ionic: Github letzter Commit: 14.10.2015
\end{itemize}

\textbf{Frameworks Conclusio}
Es war grundsätzlich für uns bereits von Beginn an klar dass wir ein Framework verwenden würden, allerdings tendieren wir mittlerweile in die Richtung eines hybriden Frameworks. Codename One und appmethod fallen aufgrund ihrer mangelnden kostenfreien Option definitiv weg. Ionic und Firebase scheinen schon weit interessanter.
Da muss man sich allerdings eine Grundsatzfrage stellen - möchten wir eine HTML hybride App bauen oder nur eine cross-platform App? Denn für eine HTML hybride App müssten wir Ionic verwenden, auch wenn einige von uns dafür definitiv AngularJS und JS im allgemeinen wiederholen müssten.


\subsection {Datenbank}
Die Datenbank wird mir in Form einer NoSQL Datenbank von Herrn Melichar zur Verfügung stehen, bei welcher die Daten dann mittels Funktionen ausgelesen werden können. 


\subsection {Nutzwertanalyse}
\textbf{Nutzen für den Entwickler}
Der Nutzwert für mich als Entwickler besteht in meinem gewonnen Coding-Können und in Gewinn meiner Erfahrung im Teamwork und nicht zuletzt natürlich in meiner positiven (oder hoffentlich besseren) Diplomarbeit.
\textbf{Nutzen für den Kunden}
Der Nutzwert für den Kunden ist dass er zu einem recht geringen Preis ein Tool an die Hand bekommt mit welchem er unsere eigene App und Webapplikation verwenden kann, aber den CarPC theoretisch auch noch erweitern könnte und selbst etwas erweitertes aus der Idee den günstigen CarPC machen, da wir geplant haben den CarPC OpenSource zu machen und auch die Baupläne online zur Verfügung zu stellen. 


\subsection {Betriebssystem}
Das Betriebssystem des Rasberry Pi2 ist eine performance-optimierte Version von Debian Linux.
Das Betriebssystem der App wird Android sein, auch wenn wir durch das Framework das wir verwenden die App auf jedem der mobil vorhandenen App Stores publizieren könnten.


\subsection {Conclusio}
Abschließend wird innerhalb der Festlegung der User Stories vor allem darauf zu achten sein möglichst wenige Eingaben vom User abzuverlangen und möglichst viel direkt aus der OBD2 Schnittstelle mittels der PID's zu bekommen, da dies ein großes Fehlerpotenzial bergen würde. 
Ein Framework wird auch sehr wichtig sein um die Arbeit an der App möglichst fehlerfrei und unterbrechungsfrei zu ermöglichen. Hierfür muss eine Testapplikation mit Ionic geschrieben werden um zu sehen ob es fehlerfrei genug ist um es während der Fahrt einsetzen zu können, da es hierfür möglichst wenige Fehler bergen sollte um den Fahrer nicht abzulenken. Andernfalls könnte man auf Firebase zurückgreifen.
